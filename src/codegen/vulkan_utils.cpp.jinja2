#include <codegen/vulkan_utils.hpp>
#include <utils/assert.hpp>

#include <format/vulkan.hpp>

#include <algorithm>
#include <iterator>
#include <limits>
#include <unordered_map>
#include <vector>

namespace codegen::vulkan
{

namespace
{

struct FormatPlane
{
    vk::Format compatibleFormat = vk::Format::eUndefined;
    uint32_t heightDivisor = 1;
    uint32_t widthDivisor = 1;
};

struct Format
{
    vk::DeviceSize blockSize = VK_WHOLE_SIZE;
    std::vector<FormatPlane> planes;
    SpvImageFormat spvImageFormat = SpvImageFormatUnknown;
};

const std::unordered_map<vk::Format, Format> kFormats = {
    {% for format in formats %}
    {
        {{ format.format_cpp_name }},  // {{ format.format_name }}
        Format{
            .blockSize = {{ format.block_size }},
            {% if format.planes %}
            .planes = {
                {% for plane in format.planes %}
                FormatPlane{
                    .compatibleFormat = {{ plane.compatible_cpp_format_name }},  // {{ plane.compatible_format_name }}
                    .heightDivisor = {{ plane.height_divisor }},
                    .widthDivisor = {{ plane.width_divisor }},
                },
                {% endfor %}
            },
            {% endif %}
            {% if format.spirv_image_format %}
            .spvImageFormat = SpvImageFormat{{ format.spirv_image_format }},
            {% endif %}
        },
    },
    {% endfor %}
};

vk::DeviceSize formatStencilBitSize(vk::Format format)
{
    switch (format) {
    case vk::Format::eD16UnormS8Uint:
    case vk::Format::eD24UnormS8Uint:
    case vk::Format::eD32SfloatS8Uint:
    case vk::Format::eS8Uint:
        return 8;
    default:
        INVARIANT(false, "Stencil size of format '{}' is not known", format);
    }
}

vk::DeviceSize formatDepthBitSize(vk::Format format)
{
    switch (format) {
    case vk::Format::eD16Unorm:
    case vk::Format::eD16UnormS8Uint:
        return 16;
    case vk::Format::eD24UnormS8Uint:
    case vk::Format::eX8D24UnormPack32:
        return 24;
    case vk::Format::eD32Sfloat:
    case vk::Format::eD32SfloatS8Uint:
        return 32;
    default:
        INVARIANT(false, "Depth size of format '{}' is not known", format);
    }
}

uint32_t getPlaneIndex(vk::ImageAspectFlagBits imageAspect)
{
    switch (imageAspect) {
    case vk::ImageAspectFlagBits::ePlane0:
        return 0;
    case vk::ImageAspectFlagBits::ePlane1:
        return 1;
    case vk::ImageAspectFlagBits::ePlane2:
        return 2;
    default:
        INVARIANT(false, "Plane index for image apsect '{}' is not known", imageAspect);
    }
}

}  // namespace

const std::unordered_set<vk::Format> kMultiplaneFormats = {
    {% set max_length = formats | selectattr('planes') | map(attribute='format_cpp_name') | map('length') | max %}
    {% for format in formats | selectattr('planes') %}
    {% set indent_comment = max_length - (format.format_cpp_name | length) %}
    {{ format.format_cpp_name }}, {{ ' ' * indent_comment }} // {{ format.format_name }}
    {% endfor %}
};

const std::unordered_set<vk::Format> kFormatHasSpvImageFormat = {
    {% set max_length = formats | selectattr('spirv_image_format') | map(attribute='format_cpp_name') | map('length') | max %}
    {% for format in formats | selectattr('spirv_image_format') %}
    {% set indent_comment = max_length - (format.format_cpp_name | length) %}
    {{ format.format_cpp_name }}, {{ ' ' * indent_comment }} // {{ format.format_name }} -> SpvImageFormat{{ format.spirv_image_format }}
    {% endfor %}
};

const std::unordered_map<SpvImageFormat, vk::Format> kSpvImageFormatToVkFormat = {
    {% for format in formats | selectattr('spirv_image_format') %}
    {
        SpvImageFormat{{ format.spirv_image_format }},
        {{ format.format_cpp_name }},  // {{ format.format_name }}
    },
    {% endfor %}
};

vk::DeviceSize formatElementSize(vk::Format format, vk::ImageAspectFlagBits imageAspect)
{
    if (imageAspect == vk::ImageAspectFlagBits::eStencil) {
        return formatStencilBitSize(format) / 8;
    } else if (imageAspect == vk::ImageAspectFlagBits::eDepth) {
        return formatDepthBitSize(format) / 8;
    }
    auto f = kFormats.find(format);
    INVARIANT(f != std::end(kFormats), "Format '{}' is not known", format);
    if (!std::empty(f->second.planes)) {
        uint32_t planeIndex = getPlaneIndex(imageAspect);
        format = f->second.planes.at(planeIndex).compatibleFormat;
        f = kFormats.find(format);
        INVARIANT(f != std::end(kFormats), "Format '{}' is not known", format);
    }
    return f->second.blockSize;
}

}  // namespace codegen::vulkan
